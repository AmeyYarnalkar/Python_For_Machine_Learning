# Exception Handling
##  What an exception REALLY is

An **exception** is Python saying:

> “I can’t continue normally.”
> 

Not:

- a syntax error
- not a crash (unless unhandled)
- not something rare

Exceptions are **part of normal control flow**.

---

##  Basic structure (must-know)

```python
try:
    x = int("10")
except ValueError:
    print("conversion failed")

```

Meaning:

- Try risky code
- Catch specific failure
- Program continues

If you don’t catch it → program stops.

---

##  Why `try/except` exists 

**NOT** for hiding bugs.

**YES** for:

- invalid user input
- network failure
- file not found
- external systems
- expected failure scenarios

If a bug is *your fault* → let it crash.

---

##  Catching specific exceptions (MANDATORY)

```python
try:
    x = int("abc")
except ValueError:
    print("invalid number")

```

 This is lazy and dangerous:

```python
except:
    pass

```

If you write this in interviews → red flag.

---

##  Multiple exceptions

```python
try:
    x = int(input())
    y = 10 / x
except ValueError:
    print("not a number")
except ZeroDivisionError:
    print("division by zero")

```

Order matters.

Specific → general.

---

##  Catching multiple at once

```python
except (ValueError, ZeroDivisionError):
    print("invalid input")

```

Use this **only** if handling is identical.

---

##  `else` block (underrated but clean)

```python
try:
    x = int("10")
except ValueError:
    print("failed")
else:
    print("success")

```

Runs only if **no exception occurred**.

Cleaner than putting logic inside `try`.

---

##  `finally` (guaranteed execution)

```python
try:
    file = open("data.txt")
except FileNotFoundError:
    print("missing file")
finally:
    print("cleanup")

```

Used for:

- closing files
- releasing resources
- cleanup logic

Runs **no matter what**.

---

##  Raising exceptions 

You **should** raise exceptions.

```python
def withdraw(balance, amount):
    if amount > balance:
        raise ValueError("insufficient balance")
    return balance - amount

```

Exceptions are **signals**, not failures.

---

##  Custom exceptions 

```python
class InvalidAgeError(Exception):
    pass

def vote(age):
    if age < 18:
        raise InvalidAgeError("too young")

```

Use custom exceptions when:

- business rules fail
- domain logic matters

---

##  Re-raising exceptions 

```python
try:
    risky()
except ValueError:
    print("logging")
    raise

```

You handled something **partially**

but still want the error to propagate.

---

## 2️ Exception hierarchy

```
Exception
 ├── ValueError
 ├── TypeError
 ├── IndexError
 ├── KeyError
 ├── FileNotFoundError

```

Catching `Exception` is okay **at boundaries**

(API layer, CLI entry, main loop)

Not inside core logic.

---
**Also Study About How can you print execution stack?**\
**Explore the syntax `Exception as e`**?
