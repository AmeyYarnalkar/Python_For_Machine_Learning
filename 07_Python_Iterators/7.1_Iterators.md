
# ITERATORS IN PYTHON 

## What is an Iterator?

An **iterator** is an object that:

* Returns one value at a time
* Remembers its current position
* Raises `StopIteration` when no items are left

It does **not** return all values at once.

---

##  Iterable vs Iterator (Very Important)

###  Iterable

An object that can be looped over.

Examples:

* list
* tuple
* string
* set
* dictionary

An iterable does **not** keep track of position.

---

###  Iterator

An object that:

* Is created from an iterable
* Keeps track of position
* Produces next value using `next()`

---

##  How to Create an Iterator

```python
numbers = [10, 20, 30]
it = iter(numbers)
```

`iter()` converts an iterable into an iterator.

---

## 4️⃣ How `next()` Works

```python
next(it)  # 10
next(it)  # 20
next(it)  # 30
next(it)  # StopIteration
```

Important:

* `next()` returns a value
* It does not print automatically
* When exhausted → raises `StopIteration`

---

##  What a `for` Loop Really Does

This:

```python
for x in [1, 2, 3]:
    print(x)
```

Is internally similar to:

```python
it = iter([1, 2, 3])

while True:
    try:
        x = next(it)
        print(x)
    except StopIteration:
        break
```

A `for` loop automatically:

* Creates iterator
* Calls `next()`
* Stops on `StopIteration`

---

##  Why Use Iterators Manually?

Because you get control.

You can:

* Pause iteration
* Resume later
* Fetch values only when needed
* Handle huge data efficiently

Example:
Reading large files line by line instead of loading everything into memory.

---

##  Memory Advantage

Iterator:

* Produces values one at a time
* Doesn’t store everything at once
* More memory efficient

This is why generators (which are iterators) are powerful.

---

##  Iterator Protocol 

An object is an iterator if it implements:

* `__iter__()`
* `__next__()`

`__next__()` → returns next value
When done → raises `StopIteration`

---

