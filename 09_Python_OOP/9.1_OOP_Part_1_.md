

# Python OOP ‚Äî Part 1 

## Why OOP Exists

Problem with only functions:

* Data lives separately from behaviour
* Hard to manage many related states
* Global variables create messy design

üëâ OOP solves this by bundling:

```
State (data) + Behaviour (functions)
```

inside a single unit ‚Üí **object**

---

## Class vs Object

### Class

* Blueprint / design
* Defines attributes and methods
* No real data stored for instances

Example:

```python
class Person:
    pass
```

---

### Object

* Instance created from class
* Has its own memory and state

```python
p1 = Person()
p2 = Person()
```

Key idea:

```
Same blueprint
Different memory
Independent state
```

---

## Methods and `self`

A method is just a function inside a class.

```python
class Person:
    def greet(self):
        print("Hello")
```

When calling:

```python
p1.greet()
```

Python internally does:

```python
Person.greet(p1)
```

üëâ `self` = the object calling the method.

Purpose of `self`:

* Identify which object's data to use
* Allow instance-specific behaviour

---

## Adding State (Instance Attributes)

```python
class Person:
    def set_name(self, name):
        self.name = name
```

Two variables exist:

```
name        ‚Üí local parameter
self.name   ‚Üí attribute stored in object
```

Instance attributes live inside:

```
object.__dict__
```

Example:

```python
p1.__dict__   ‚Üí {'name': 'Amey'}
```

---

## Constructor (`__init__`)

Used to initialise objects at creation.

```python
class Person:
    def __init__(self, name):
        self.name = name
```

When we create:

```python
p1 = Person("Amey")
```

Python does:

```
Create empty object
Call __init__(p1, "Amey")
Store data inside object
```

Why constructors?

* Enforce required data
* Prevent incomplete objects
* Improve design safety

---

## Dynamic Attribute Creation

Python allows:

```python
p1.age = 22
```

Even if not defined in class.

Internally:

```
p1.__dict__ ‚Üí {'name': 'Amey', 'age': 22}
```

‚ö†Ô∏è Flexible but risky:

* Breaks consistency between objects
* Can cause runtime errors

Good design ‚Üí initialise important attributes in `__init__`.

---

## Class Variables vs Instance Variables

### Class Variable

Defined inside class body:

```python
class Person:
    species = "Human"
```

Stored in:

```
Person.__dict__
```

Shared by all objects.

---

### Instance Variable

Defined using:

```python
self.variable = value
```

Stored in:

```
object.__dict__
```

Unique per object.

---

### Attribute Lookup Chain

When accessing:

```python
p1.species
```

Python searches:

```
1. p1.__dict__
2. Person.__dict__
```

---

##  Important Rule

Assignment through object:

```python
p1.species = "Alien"
```

Does NOT change class variable.

Instead:

```
Creates new entry in p1.__dict__
```

Class variable changes only via:

```python
Person.species = "Alien"
```

---

## Encapsulation

Meaning:

```
Control how attributes are accessed or modified
```

Goal:

* Protect object state
* Prevent invalid updates

---

### Single Underscore `_var`

Convention-based protection:

```python
self._balance
```

Means:

```
"Internal use ‚Äî don‚Äôt access directly"
```

Python trusts developers.

---

### Double Underscore `__var` (Name Mangling)

```python
self.__balance
```

Python renames internally:

```
_ClassName__balance
```

Example:

```
_BankAccount__balance
```

Purpose:

üëâ Avoid name conflicts in inheritance
(Not true privacy)

---

## Python‚Äôs Philosophy on Encapsulation

Python does NOT enforce strict privacy.

Design principle:

```
Consenting Adults Philosophy
```

Meaning:

* Language trusts developers
* Flexibility over strict restriction

---

