# Python Decorators 

## What Is a Decorator?

A decorator is:

ðŸ‘‰ A function that takes another function \
ðŸ‘‰ Adds extra behavior \
ðŸ‘‰ Returns a new function 

Under the hood:

```python
@decorator
def func():
    pass
```

Is exactly equal to:

```python
def func():
    pass

func = decorator(func)
```

No magic.

---

## Basic Structure

```python
def decorator(f):
    def wrapper():
        # before
        f()
        # after
    return wrapper
```

When used:

```python
@decorator
def greet():
    print("Hello")
```

`greet` becomes the `wrapper`.

The original function is replaced.

---

## When Does the Decorator Run?

Important:

The decorator runs at **function definition time**, not at function call time.

But the wrapper logic runs at function call time.

---

## Why Use Decorators?

They let you:

* Add logging
* Add validation
* Add authentication
* Measure execution time
* Retry logic
* Modify behavior
* Enforce rules

Without modifying original function code.

This is called:

ðŸ‘‰ Cross-cutting concern handling.

---

## Decorators With Arguments

If function has parameters:

```python
def decorator(f):
    def wrapper(*args, **kwargs):
        return f(*args, **kwargs)
    return wrapper
```

Use `*args, **kwargs` to handle any function signature.

---

## Preserving Metadata (`functools.wraps`)

Without this:

* Function name changes to "wrapper"
* Docstring is lost

Proper way:

```python
from functools import wraps

def decorator(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        return f(*args, **kwargs)
    return wrapper
```

This preserves:

* `__name__`
* `__doc__`
* Other metadata

---

## Decorator With Arguments (Advanced Pattern)

Sometimes you want:

```python
@decorator(10)
def func():
    pass
```

That requires:

```python
def decorator(n):
    def actual_decorator(f):
        def wrapper(*args, **kwargs):
            return f(*args, **kwargs)
        return wrapper
    return actual_decorator
```

So structure becomes:

```
decorator(args) â†’ returns decorator
decorator(f) â†’ returns wrapper
```

Thatâ€™s why there are 3 layers.

---

## Built-in Decorators You Already Learned

* `@property`
* `@classmethod`
* `@staticmethod`

They are just decorators implemented inside Python.

Example:

`@classmethod` converts function into descriptor that passes `cls`.

---

