

# Python OOP Part 2


## Inheritance

### Meaning

Inheritance allows a class (child) to reuse and extend another class (parent).

```python
class Animal:
    def speak(self):
        print("Some sound")

class Dog(Animal):
    pass
```

Here:

```
Dog inherits from Animal
```

So:

```python
d = Dog()
d.speak()
```

Works.

---

### How Method Lookup Works

When you call:

```python
d.speak()
```

Python searches in order:

```
1. d.__dict__
2. Dog.__dict__
3. Animal.__dict__
4. object
```

This order is part of **MRO (Method Resolution Order)**.

---

## Method Overriding

Child can redefine parent method:

```python
class Dog(Animal):
    def speak(self):
        print("Bark")
```

Now:

```
Dog's version runs
```

Reason:

Python finds method in `Dog.__dict__` before checking `Animal`.

---

## Constructors in Inheritance

If child does NOT define `__init__`, parent constructor runs automatically.

```python
class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    pass

d = Dog("Tom")
```

Internally:

```
Animal.__init__(d, "Tom")
```

---

### Important Case

If child defines its own constructor:

```python
class Dog(Animal):
    def __init__(self, breed):
        self.breed = breed
```

Now:

```
Animal.__init__ does NOT run automatically
```

So `self.name` won’t exist.

---

## `super()`

Correct way:

```python
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)
        self.breed = breed
```

###  What `super()` Actually Means

It does NOT mean:

```
Call my parent
```

It means:

```
Call the next class in the MRO chain
```

---

## MRO (Method Resolution Order)

Example:

```python
class D(B, C):
```

If:

```
B → A
C → A
```

MRO becomes:

```
D → B → C → A → object
```

Important facts:

* Order inside class definition matters (left to right priority).
* Each class appears only once.
* Solves the Diamond Problem.

---

## Diamond Problem

Structure:

```
      A
     / \
    B   C
     \ /
      D
```

Without MRO logic, `A` could run twice.

Python avoids this by building one linear order (C3 linearization).

So `A` appears only once.

---

## `@classmethod`

Used when method needs class-level access.

```python
class Person:
    species = "Human"

    @classmethod
    def get_species(cls):
        return cls.species
```

Key points:

* First parameter is `cls`
* Refers to the class object
* Dynamic (if inherited, `cls` becomes subclass)

---

## Difference

```
self → instance
cls  → class
```

---

## `@staticmethod`

Used when method:

* Does not need instance
* Does not need class
* But logically belongs to class

```python
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b
```

Purely organizational.

---

## `@property`

Used for controlled attribute access.

Unsafe version:

```python
self.age = age
```

Safe version:

```python
class Person:
    def __init__(self, age):
        self._age = age

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        if value < 0:
            raise ValueError("Age cannot be negative")
        self._age = value
```

---

### Why `_age`?

Because:

```
self.age inside getter → infinite recursion
```

So:

```
Public interface → age
Internal storage → _age
```

---

### Why `@property` is Better Than get/set Methods

* Cleaner API (`p.age` not `p.get_age()`)
* Backward compatibility
* Validation without changing external usage

---

## Magic (Dunder) Methods

These let objects behave like built-in types.

### `__str__`

Controls what `print(obj)` shows.

### `__repr__`

Developer/debug representation.

### `__len__`

Allows `len(obj)`.

### `__add__`

Allows `obj1 + obj2`.

Frameworks like PyTorch heavily use these.

---

