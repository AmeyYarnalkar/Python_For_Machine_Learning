

# Python Generators 



##  Why Generators Exist

Problem:

* Lists store all values in memory.
* Large data = high memory usage.
* Sometimes we donâ€™t need everything at once.

Solution:

ðŸ‘‰ Generate values **only when needed**.

This is called **lazy evaluation**.

---

## What Is a Generator?

A generator is:

> A special type of iterator created using `yield`.

Important:

* It behaves like an iterator.
* It remembers its state.
* It produces values one at a time.
* It raises `StopIteration` when done.

---

## Generator Function

A function becomes a generator when it contains `yield`.

Example:

```python
def count():
    yield 1
    yield 2
    yield 3
```

Key behavior:

```python
c = count()
```

ðŸ‘‰ Nothing runs yet.
It only creates a **generator object**.

Execution starts only when:

```python
next(c)
```

---

## How `yield` Works

Normal function:

```python
return
```

* Returns value
* Destroys function frame

Generator function:

```python
yield
```

* Returns value
* Pauses execution
* Preserves:

  * Local variables
  * Current line
  * Execution state
* Resumes from same point on next `next()`

---

## Execution Timeline Example

```python
def test():
    print("A")
    yield 1
    print("B")
    yield 2
```

### Step-by-step:

```python
t = test()
```

Nothing prints.

```python
next(t)
```

Prints: A
Returns: 1
Pauses at first yield.

```python
next(t)
```

Prints: B
Returns: 2
Pauses again.

```python
next(t)
```

Raises: StopIteration

---

## Generators Are One-Time Use

```python
gen = (x*x for x in range(3))

for v in gen:
    print(v)

for v in gen:
    print(v)
```

Second loop prints nothing.

Reason:

ðŸ‘‰ Generators are **exhausted after use**.

They donâ€™t reset.

---

## Generator Expression

List comprehension:

```python
[x for x in range(5)]
```

Creates full list in memory.

Generator expression:

```python
(x for x in range(5))
```

Creates generator object.

Does NOT compute values immediately.

---

## Infinite Generators

Example:

```python
def counter():
    i = 1
    while True:
        yield i
        i += 1
```

Why safe?

Because:

* It runs only until next `yield`
* It doesnâ€™t execute infinite loop at once
* It runs in controlled slices

---

## Memory Difference

List:

* Stores all values
* High memory usage

Generator:

* Stores only:

  * Current position
  * Local variables
  * Execution state

Much more memory efficient.

---

# # Where Used in ML

You donâ€™t need advanced generator theory for ML.

But you will use generators for:

* Reading large dataset files
* Streaming data
* Batch processing
* Data pipelines
* Avoiding loading full dataset into memory

---

