
# Python Closures 


## What is a Closure?

A closure is:

> A function that remembers variables from its enclosing scope even after that outer function has finished executing.

It happens when:

* There is a nested function
* The inner function uses a variable from the enclosing (non-global) scope
* The outer function returns the inner function

---

## Basic Example

```python
def outer():
    x = 10
    
    def inner():
        print(x)
        
    return inner

f = outer()
f()
```

### What happens?

* `outer()` runs
* `x = 10` is created
* `inner` is created
* `outer()` returns `inner`
* Outer stack frame is destroyed
* BUT `x` is preserved

Why?

Because `inner()` holds a reference to `x`.

If reference count ≠ 0 → object not destroyed.

---

## When Does Closure NOT Happen?

If inner function does not reference outer variable:

```python
def outer():
    x = 10
    
    def inner():
        print("hello")
        
    return inner
```

Here:

* `inner()` does not use `x`
* No reference to `x`
* `x` is destroyed normally
* No closure formed

---

## Important Rule — Compile Time Decision

Python decides variable scope at compile time.

If a variable is assigned anywhere inside a function, Python treats it as local.

Example:

```python
def outer():
    x = 10
    
    def inner():
        print(x)
        x = 20
        
    return inner
```

Result → `UnboundLocalError`

Why?

Because:

* `x = 20` exists
* Python marks `x` as local
* `print(x)` tries to use local `x` before assignment

---

## Using `nonlocal`

`nonlocal` tells Python:

> This variable belongs to the enclosing scope, not local.

Example:

```python
def outer():
    x = 10
    
    def inner():
        nonlocal x
        x = x + 1
        print(x)
        
    return inner
```

Now:

```python
f = outer()
f()  # 11
f()  # 12
f()  # 13
```

Why does it increase?

Because:

* Same preserved `x`
* Not recreated
* `outer()` runs only once
* We modify stored closure state

---

## Mutation vs Reassignment (Very Important)

### Mutation (No `nonlocal` needed)

```python
def outer():
    x = []
    
    def inner():
        x.append(1)
        print(x)
        
    return inner
```

Works without `nonlocal`.

Why?

* We are modifying the object
* Not rebinding `x`
* Name `x` still refers to same list

---

### Reassignment (Needs `nonlocal`)

```python
def outer():
    x = []
    
    def inner():
        x = x + [1]
        print(x)
        
    return inner
```

This fails without `nonlocal`.

Why?

* `x = x + [1]` creates new list
* Rebinds name `x`
* Python marks `x` as local
* Causes `UnboundLocalError`

---

## What Closure Actually Stores

Closure does NOT store the stack frame.

It stores:

* A cell object containing the preserved variable

You can inspect it:

```python
f = outer()
print(f.__closure__)
```

It shows tuple of cell objects.

Closure stores:

* The variable name
* A reference to the object

Remember:

Variable → stores reference
Closure → stores variable cell

---

## Formal Conditions for Closure

Closure happens only if:

1. Nested function exists
2. Inner function references enclosing variable
3. Outer function returns inner function

If reference is missing → no closure

---

