# Python Numeric Data â€” Notes

Python stores numbers as **objects**, not primitive memory types like C/Java.
That means numbers carry behavior (methods, rules, precision handling) along with value.

Python mainly uses **three numeric types**:

```
int      â†’ whole numbers
float    â†’ decimal numbers
complex  â†’ numbers with imaginary part
```

---

# Integers (`int`)

### What they are

Whole numbers â€” positive, negative, or zero.

```
10
-5
0
999999999999999
```

###  Key characteristics

* **Unlimited size** (no overflow like Java/C++ int)
* Stored dynamically â€” Python allocates more memory when needed.
* Exact precision â€” no rounding errors.

```
x = 100
y = -42
big = 10**100   # very large integer
```

### âš ï¸ But but..

Unlimited size doesnâ€™t mean unlimited speed.
Huge integers slow down calculations because Python handles them manually.

---

# Float (`float`)

###  What they are

Numbers with decimals.

```
3.14
-0.5
2.0
```

Python uses **double-precision floating point (64-bit)** internally.

---

## Decimal Concept (Important)

Floats represent numbers using **binary fractions**, not base-10 decimals.

So some values **cannot be stored exactly**.

Example:

```
0.1 + 0.2
```

You might expect `0.3`, but Python may show:

```
0.30000000000000004
```

This isnâ€™t a mistake in Python, itâ€™s just how computers handle decimal numbers.

Computers donâ€™t store numbers the way we write them (base-10).
They use **binary (base-2)**, and some decimal values like **0.1** and **0.2** cannot be represented exactly in binary form. So instead of storing the perfect value, Python stores a **very close approximation**. When you add those approximations together, the tiny error becomes visible, which is why you might see something like `0.30000000000000004` instead of a clean `0.3`.

In simple terms:
Python isnâ€™t getting the math wrong â€” itâ€™s just showing the small rounding limits that come from how computers store decimal numbers internally.


---

## Precision

Precision = how many digits Python can represent reliably.

* Python floats â‰ˆ **15â€“17 decimal digits of precision**.
* After that, rounding errors happen.

Example idea:

```
1.1234567890123456   # ok
1.1234567890123456789 # loses precision
```

### When precision matters:

* money
* scientific calculations

In such cases, people use the `decimal` module â€” but thatâ€™s beyond basic numeric types.

---

# Complex Numbers (`complex`)

###  What they are

Numbers with real + imaginary parts.

```
a + bj
```

Example:

```
z = 2 + 3j
```

* `2` â†’ real part
* `3j` â†’ imaginary part

### Why they exist

Used in:

* signal processing
* advanced math
* electrical engineering

### Keep it simple

You rarely need complex numbers in normal backend or DSA work.

---

# Type Conversion

Python allows converting between numeric types.

---

## ğŸ‘‰ Integer â†’ Float

```
x = 10
f = float(x)
```

Result:

```
10.0
```

Safe conversion â€” no data loss.

---

## ğŸ‘‰ Float â†’ Integer

```
f = 3.9
x = int(f)
```

Result:

```
3
```

### âš ï¸ Important

`int()` does **NOT** round.

It **truncates** (cuts off decimal part).

```
int(3.9)   â†’ 3
int(-3.9)  â†’ -3
```



## Rounding

Use `round()`:

```
round(3.6)     â†’ 4
round(3.1415, 2) â†’ 3.14
```

### Bankerâ€™s rounding (surprise rule)

```
round(2.5) â†’ 2
round(3.5) â†’ 4
```

Python rounds to **nearest even number** when exactly in the middle.

This prevents statistical bias.

---

## Absolute Value

Removes sign â€” gives distance from zero.

```
abs(-10) â†’ 10
abs(5)   â†’ 5
```

Works for floats and complex numbers too.

---

# Best Practices (Real Talk)

##  1. Donâ€™t compare floats using `==`

Bad:

```
if a == 0.3:
```

Better:

```
abs(a - 0.3) < 1e-9
```

Floating precision will betray you eventually.

---

##  2. Use integers when you can

Integers are:

* exact
* faster for many operations
* safer

Only use floats when decimals actually matter.

---

##  3. Know that Python auto-converts

```
5 + 2.0 â†’ 7.0
```

Python promotes to float automatically.

Mixed math changes type silently â€” be aware.

---

##  4. Avoid giant integers unless necessary

Yes Python allows huge numbers â€” but performance drops.

---

##  5. Be explicit with conversions

Donâ€™t rely on guessing types.

```
float(x)
int(y)
```

Clear code prevents subtle bugs.

---

