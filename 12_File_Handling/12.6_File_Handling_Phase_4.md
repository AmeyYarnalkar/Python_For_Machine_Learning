# Python File Handling — Phase 4 Notes

### Paths Are Not Strings

Every file reference in Python is a **path**.

Example:

```python
"data.txt"
```

This is a **relative path**, not “just a file”.

---

### Relative Path

Depends on current working directory.

```python
Path("data.txt")
```

Means:

> Look in current working directory.

---

## Absolute Path

Full path from root.

Linux/macOS:

```
/home/amey/project/data.txt
```

Windows:

```
C:\Users\Amey\project\data.txt
```

Independent of working directory.

---

## Why Use `pathlib` Instead of Strings?

Bad:

```python
"data/" + "file.csv"
```

Breaks cross-platform compatibility.

Good:

```python
from pathlib import Path

p = Path("data") / "file.csv"
```

Benefits:

* Cross-platform safe
* Correct path separators
* Structured object
* Not just string manipulation

---

## Path Object

```python
p = Path("data/file.csv")
```

This is a:

* Path object
* NOT string
* NOT file object
* NOT automatically absolute

---

## Converting to Absolute Path

```python
p.resolve()
```

* Converts relative → absolute
* Resolves `..`
* Resolves symbolic links
* Based on current working directory

---

## Getting Script Directory

Working directory ≠ script location.

To get script directory:

```python
base_dir = Path(__file__).parent
```

* `__file__` → current script path
* `.parent` → directory containing script

Move up hierarchy:

```python
Path(__file__).parent.parent
```

Each `.parent` moves one level up.

---

## Checking Existence

```python
p.exists()
```

Returns True if:

* File exists
* OR directory exists

Does NOT check extension.

---

### Distinguishing File vs Directory

```python
p.is_file()
p.is_dir()
```

---

## Creating Directories

Basic:

```python
Path("new_folder").mkdir()
```

If exists → `FileExistsError`

---

### Safe Creation

```python
Path("new_folder").mkdir(exist_ok=True)
```

---

### Creating Nested Directories

```python
Path("parent/child").mkdir(parents=True, exist_ok=True)
```

* `parents=True` → create missing parents
* `exist_ok=True` → no error if already exists

Idempotent behavior.

---

## Deleting Files

```python
p.unlink()
```

If file does not exist → `FileNotFoundError`

Safe version:

```python
p.unlink(missing_ok=True)
```

---

## Listing Directory Contents

```python
for item in folder.iterdir():
    print(item)
```

Returns:

* Files
* Directories

---

### Only Files

```python
for item in folder.iterdir():
    if item.is_file():
        print(item)
```

---

## Pattern Matching

### Current Directory Only

```python
folder.glob("*.csv")
```

### Recursive (Subdirectories Included)

```python
folder.rglob("*.csv")
```

`rglob` = recursive glob

---

## Path Attributes

Given:

```python
p = Path("data/file.csv")
```

* `p.name` → `"file.csv"`
* `p.stem` → `"file"`
* `p.suffix` → `".csv"`

---

### Multi-Extension Case

```python
p = Path("archive.tar.gz")
```

* `p.name` → `"archive.tar.gz"`
* `p.suffix` → `".gz"`
* `p.suffixes` → `[".tar", ".gz"]`
* `p.stem` → `"archive.tar"`

To remove all suffixes:

```python
Path(p.stem).stem
```

---

## Parent Paths

```python
p = Path("/home/amey/project/data/file.csv")
```

* `p.parent` → `/home/amey/project/data`
* `p.parent.name` → `"data"`
* `p.parent.parent` → `/home/amey/project`

`.parent` returns full path object, not just folder name.

---

## Phase 4 Core Summary

* Never treat paths like raw strings
* Use `/` operator for joining
* Use `resolve()` for absolute paths
* Use `__file__` for script-relative paths
* Use `.is_file()` and `.is_dir()`
* Use `parents=True` for nested directory creation
* Use `glob()` and `rglob()` for pattern matching
* Understand `.stem`, `.suffix`, `.suffixes`
* Know difference between `.parent` and `.parent.name`

---

