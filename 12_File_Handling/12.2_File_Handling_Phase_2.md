
#  Python File Handling ‚Äî Phase 2 Notes

## Memory-Safe Reading

###  Dangerous Pattern

```python
data = f.read()
```

* Loads entire remaining file into memory
* Unsafe for large files (GBs)
* Can cause MemoryError or system slowdown

---

### Also Dangerous

```python
lines = f.readlines()
```

* Returns a **list**
* Loads all remaining lines into memory
* High memory usage

---

### Safe Pattern ‚Äî Iteration

```python
for line in f:
    process(line)
```

Why safe?

* File objects are iterable
* They use internal buffering
* Data is read lazily (on-demand)
* Memory usage stays small

This behaves similar to a generator.

---

##  Text Mode vs Binary Mode

### Text Mode (`"r"`, `"w"`)

* Returns `str`
* Performs decoding/encoding automatically
* Requires encoding awareness

Flow:

```
Disk (bytes) ‚Üí decode ‚Üí str
```

---

### Binary Mode (`"rb"`, `"wb"`)

* Returns `bytes`
* No decoding
* No encoding
* Raw byte stream

Flow:

```
Disk (bytes) ‚Üí bytes (unchanged)
```

Used for:

* Images
* Audio
* PDFs
* Model weights
* Serialized data

---

## Encoding (Critical for Data Integrity)

When opening in text mode:

```python
open("file.txt", "r")
```

Python uses system default encoding.

‚ö† Dangerous assumption.

---

### Best Practice

```python
open("file.txt", "r", encoding="utf-8")
```

Always specify encoding explicitly.

Why?

* Cross-platform consistency
* Prevents decoding ambiguity
* Avoids silent data corruption

---

### Decode Errors

If bytes don‚Äôt match specified encoding:

üëâ `UnicodeDecodeError`

This is good behavior (strict decoding).

---

### Error Handling Options

```python
errors="ignore"
errors="replace"
```

‚ö† Dangerous for ML/data pipelines.

Why?

Silent corruption is worse than crashing.

---

## Buffering (Hidden Performance Layer)

Reading and writing are buffered.

### Why?

Disk I/O is slow.

Instead of:

* Reading 1 character from disk each time

Python:

* Loads a chunk into memory (buffer)
* Serves reads from buffer
* Refills buffer when empty

---

### Important Insight

Even if you call:

```python
f.read(1)
```

It does NOT hit disk every time.

Buffer serves it.

---

### Write Buffering

When you do:

```python
f.write("Hello")
```

It does NOT immediately write to disk.

Process:

1. String ‚Üí encoded (text mode)
2. Bytes ‚Üí write buffer
3. Flushed later

---

### Buffer Flush Happens When:

* Buffer is full
* `f.flush()` is called
* `f.close()` is called
* `with` block exits

---

### Risk of Buffering

If program crashes before flush:

üëâ Data loss
üëâ Partial writes
üëâ Corrupted output

---

## Why `with` is Critical

```python
with open("file.txt") as f:
    ...
```

Guarantees:

* File closes even if exception occurs
* Buffer flushes properly
* File descriptor released
* No resource leaks

This prevents:

* ‚ÄúToo many open files‚Äù
* Memory/resource exhaustion
* Production crashes

---

## Exception Safety

Without `with`:

```python
f = open("file.txt")
data = f.read()
1 / 0
f.close()
```

File never closes.

With `with`:

File closes automatically ‚Äî even if error happens.

---

## Phase 2 Summary

* Never load huge files blindly
* Prefer iteration
* Always specify encoding
* Understand text vs binary
* Buffering improves performance
* Flushing prevents data loss
* `with` ensures deterministic cleanup

---


