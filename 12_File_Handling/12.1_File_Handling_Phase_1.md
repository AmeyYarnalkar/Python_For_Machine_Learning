# Python File Handling — Phase 1 

(Foundations — Core Mechanics)


##  What `open()` Actually Does

```python
f = open("data.txt", "r")
```

This does **NOT** load file content into memory.

It:

* Requests OS to open the file
* OS creates a **file descriptor** (a handle to the file)
* Python wraps it in a **file object**
* Cursor is initialized at position `0`

The file remains on disk.
Data is read **only when requested**.

---

## File Object = Stream Interface

A file object represents a **stream** of data.

Think:

```
Disk → OS → File Descriptor → Python File Object → You
```

Data flows only when you call:

```python
f.read()
```

---

##  File Modes

### `"r"` — Read

* File must exist
* Cursor starts at 0
* Throws `FileNotFoundError` if missing

---

### `"w"` — Write

* Creates file if not exists
* If exists → **erases all content**
* Cursor starts at 0

Dangerous if misused.

---

### `"a"` — Append

* Creates file if not exists
* Cursor automatically moves to **end**
* Does NOT delete existing content

Used for logs & history tracking.

---

### `"x"` — Exclusive Create

* Creates file only if it does NOT exist
* If exists → raises `FileExistsError`

Safest mode for preventing overwrites.

---

## Reading Data

### `f.read()`

Reads from **current cursor position to EOF**.

Dangerous for large files !!

---

### `f.read(n)`

Reads **n characters** (in text mode) from current cursor.

Example:

```
HelloWorld
```

```python
f.read(5) → "Hello"
```

Cursor moves forward by 5.

---

## 5️⃣ Cursor Behavior

File reading is **stateful**.

After reading:

Cursor automatically moves forward.

---

### `f.seek(position)`

Moves cursor to an absolute position.

```python
f.seek(0)   # go to beginning
```

---

### `f.tell()`

Returns current cursor position.

```python
f.tell() → 5
```

---

## 6️⃣ End of File (EOF)

When cursor reaches end:

```python
f.read()
```

Returns:

```
""
```

Empty string — NOT an exception.

Why?

Because EOF is expected behavior, not an error.

---

## Closing Files

### Manual close

```python
f.close()
```

If forgotten:

* File descriptors remain open
* Buffers may not flush
* OS resource exhaustion possible
* Long-running apps can crash

---

## 8️⃣ The `with` Statement

```python
with open("data.txt", "r") as f:
    data = f.read()
```

Guarantees cleanup even if:

* Exception occurs
* Code crashes
* Function exits early

This is **deterministic resource management**.

---

# Summary

A file object is:

> A controlled stream connected to disk via OS file descriptor.

Reading:

* Moves cursor
* Returns empty string at EOF

Modes define:

* Whether file must exist
* Whether content is erased
* Where cursor starts

`with` ensures safety.

---
